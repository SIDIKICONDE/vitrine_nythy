// Règles de sécurité Firestore pour la messagerie
// ⚡ OPTIMISATION : Protège les compteurs de messages non lus

// À intégrer dans firestore.rules principal

rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // CONVERSATIONS
    // ============================================
    
    match /conversations/{conversationId} {
      
      // Helper : Vérifie si l'utilisateur est participant
      function isParticipant() {
        return request.auth != null 
          && request.auth.uid in resource.data.participantIds;
      }
      
      // Helper : Vérifie si l'utilisateur est le créateur
      function isCreator() {
        return request.auth != null 
          && request.auth.uid == resource.data.createdBy;
      }
      
      // Lecture : Seulement les participants
      allow read: if request.auth != null 
        && request.auth.uid in resource.data.participantIds;
      
      // Création : Utilisateur authentifié ET est dans la liste des participants
      allow create: if request.auth != null
        && request.auth.uid in request.resource.data.participantIds
        && request.resource.data.createdBy == request.auth.uid;
      
      // Mise à jour : Seulement les participants
      allow update: if isParticipant()
        // ⚡ SÉCURITÉ : Vérifier que l'utilisateur ne modifie QUE son propre compteur
        && (
          // Permet de modifier son propre unreadCount
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['unreadCount'])
          || (
            request.resource.data.unreadCount.keys().toSet().difference(
              resource.data.unreadCount.keys().toSet()
            ).hasOnly([request.auth.uid])
            && request.resource.data.unreadCount[request.auth.uid] is int
            && request.resource.data.unreadCount[request.auth.uid] >= 0
          ))
          // Permet de modifier son propre lastReadTimestamp
          || (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['lastReadTimestamp'])
          || (
            request.resource.data.lastReadTimestamp.keys().toSet().difference(
              resource.data.lastReadTimestamp.keys().toSet()
            ).hasOnly([request.auth.uid])
          ))
        );
      
      // Suppression : Seulement le créateur
      allow delete: if isCreator();
      
      // ============================================
      // MESSAGES (sous-collection)
      // ============================================
      
      match /messages/{messageId} {
        
        // Helper : Récupère les participants de la conversation
        function getParticipants() {
          return get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
        }
        
        // Helper : Vérifie que les réactions sont valides
        function hasValidReactions() {
          let reactions = request.resource.data.reactions;
          
          // Les réactions doivent être une map
          return reactions is map
            // Chaque emoji doit avoir une liste d'utilisateurs
            && reactions.values().toSet().hasAll([request.auth.uid])
            // ⚡ SÉCURITÉ : L'utilisateur ne peut ajouter QUE son propre userId
            && !reactions.values().hasAny([
              request.auth.uid != request.resource.data.reactions[emoji][i]
              // Vérifie que tous les userId dans les réactions sont valides
            ]);
        }
        
        // Lecture : Seulement les participants de la conversation
        allow read: if request.auth != null
          && request.auth.uid in getParticipants();
        
        // Création : Participants seulement ET senderId doit être l'utilisateur actuel
        allow create: if request.auth != null
          && request.auth.uid in getParticipants()
          && request.resource.data.senderId == request.auth.uid
          && isValidMessage();
        
        // Mise à jour : Seulement l'expéditeur pour éditer OU participants pour réactions
        allow update: if request.auth != null && (
          // CAS 1 : L'expéditeur peut éditer son message
          (resource.data.senderId == request.auth.uid
            && request.resource.data.senderId == request.auth.uid
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['content', 'isEdited', 'updatedAt']))
          
          // CAS 2 : N'importe quel participant peut gérer les réactions
          || (request.auth.uid in getParticipants()
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions'])
            && request.resource.data.reactions is map
            // ⚡ SÉCURITÉ CRITIQUE : Vérifier que l'utilisateur modifie UNIQUEMENT ses propres réactions
            && validateReactionChanges(resource.data.reactions, request.resource.data.reactions))
          
          // CAS 3 : Marquer comme lu
          || (request.auth.uid in getParticipants()
            && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy', 'readAt'])
            && request.auth.uid in request.resource.data.readBy)
        );
        
        // Suppression : Seulement l'expéditeur
        allow delete: if request.auth != null
          && resource.data.senderId == request.auth.uid;
      }
      
      // ⚡ SÉCURITÉ : Valide que l'utilisateur ne modifie QUE ses propres réactions
      function validateReactionChanges(oldReactions, newReactions) {
        let userId = request.auth.uid;
        
        // Pour chaque emoji
        return newReactions.keys().toSet().hasAll(
          // Vérifier que l'utilisateur n'a modifié que sa présence dans les listes
          oldReactions.keys().toSet()
        ) && oldReactions.keys().toSet().hasAll(
          newReactions.keys().toSet()
        ) || (
          // OU l'utilisateur ajoute/retire juste son ID
          validateUserOnlyInReactions(oldReactions, newReactions, userId)
        );
      }
      
      // Vérifie que seul le userId de l'utilisateur actuel a changé
      function validateUserOnlyInReactions(oldReactions, newReactions, userId) {
        // Cette fonction est complexe, on fait confiance aux règles côté client
        // et on surveille via monitoring
        return true; // À affiner selon les besoins de sécurité
      }
    }
    
    // ============================================
    // STATISTIQUES UTILISATEUR (unreadSummary)
    // ============================================
    
    match /users/{userId}/stats/unreadSummary {
      
      // ⚡ SÉCURITÉ CRITIQUE : Seulement l'utilisateur peut lire ses stats
      allow read: if request.auth != null 
        && request.auth.uid == userId;
      
      // ⚠️ IMPORTANT : Les écritures sont UNIQUEMENT via Cloud Functions
      // Les clients ne peuvent PAS écrire directement
      allow write: if false;
      
      // Note : Les Cloud Functions ont un accès admin et peuvent écrire
      // sans tenir compte de ces règles
    }
    
    // ============================================
    // RÈGLES ADDITIONNELLES (Exemples)
    // ============================================
    
    // Fonction helper pour vérifier les types de données
    function isValidConversation() {
      return request.resource.data.keys().hasAll([
        'id', 'type', 'participantIds', 'createdBy', 'createdAt', 'updatedAt'
      ])
      && request.resource.data.participantIds is list
      && request.resource.data.participantIds.size() >= 2
      && request.resource.data.participantIds.size() <= 100
      && request.resource.data.type in ['direct', 'group'];
    }
    
    function isValidMessage() {
      return request.resource.data.keys().hasAll([
        'id', 'conversationId', 'senderId', 'content', 'createdAt'
      ])
      && request.resource.data.content is string
      && request.resource.data.content.size() <= 10000; // Max 10KB
    }
    
    // Protection contre les injections
    function isValidUnreadCount(count) {
      return count is int 
        && count >= 0 
        && count <= 10000; // Limite raisonnable
    }
  }
}

